version: "3.8"

services:
  traefik:
    image: "traefik"
    restart: always
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.mytlschallenge.acme.tlschallenge=true"
      - "--certificatesresolvers.mytlschallenge.acme.email=${SSL_EMAIL}"
      - "--certificatesresolvers.mytlschallenge.acme.storage=/letsencrypt/acme.json"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - traefik_data:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro

  n8n:
    image: docker.n8n.io/n8nio/n8n
    restart: always
    # We remove the host port binding '127.0.0.1:5678:5678' since Traefik handles external access.
    # The container port '5678' is still exposed internally to the Docker network.
    ports:
      - "127.0.0.1:5678:5678" # Only expose to localhost if you need local access outside Traefik
    labels:
      # n8n Traefik Labels (Assuming n8n is accessed via a subdomain)
      - traefik.enable=true
      - traefik.http.routers.n8n.rule=Host(`${SUBDOMAIN}.${DOMAIN_NAME}`)
      - traefik.http.routers.n8n.tls=true
      - traefik.http.routers.n8n.entrypoints=web,websecure
      - traefik.http.routers.n8n.tls.certresolver=mytlschallenge
      - traefik.http.middlewares.n8n.headers.SSLRedirect=true
      - traefik.http.middlewares.n8n.headers.STSSeconds=315360000
      - traefik.http.middlewares.n8n.headers.browserXSSFilter=true
      - traefik.http.middlewares.n8n.headers.contentTypeNosniff=true
      - traefik.http.middlewares.n8n.headers.forceSTSHeader=true
      - traefik.http.middlewares.n8n.headers.SSLHost=${DOMAIN_NAME}
      - traefik.http.middlewares.n8n.headers.STSIncludeSubdomains=true
      - traefik.http.middlewares.n8n.headers.STSPreload=true
      - traefik.http.routers.n8n.middlewares=n8n@docker
    environment:
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_HOST=${SUBDOMAIN}.${DOMAIN_NAME}
      - N8N_PORT=5678
      - N8N_PROTOCOL=https
      - N8N_RUNNERS_ENABLED=true
      - NODE_ENV=production
      - WEBHOOK_URL=https://${SUBDOMAIN}.${DOMAIN_NAME}/
      - GENERIC_TIMEZONE=${GENERIC_TIMEZONE}
      - TZ=${GENERIC_TIMEZONE}
      # Optional: Add environment variables for the new services
      # - BROWSERLESS_URL=http://browserless:3000
      # - STITCHER_URL=http://stitcher:4000
    volumes:
      - n8n_data:/home/node/.n8n
      - ./local-files:/files

  ### START NEW SERVICES ###

  # 1. Browserless Deployment
  browserless:
    image: ghcr.io/browserless/chromium:v2.38.2
    restart: always
    # No external port needed as n8n will access it via the internal network
    # The port 3000 is still exposed internally
    environment:
      - CONCURRENT=10
      - TIMEOUT=600000
      - TOKEN=6R0W53R135510 # It's generally better to move this to a .env file
      # You can add a Traefik rule if you want external access to Browserless (e.g., for debugging)
      # traefik.enable=true
      # traefik.http.routers.browserless.rule=Host(`browserless.${DOMAIN_NAME}`)
      # ... other Traefik labels ...

  # 2. Stitcher Service Deployment
  stitcher:
    image: image-stitcher-api # Replace with the actual image name if different, assuming you built this
    container_name: stitcher # Use a standard name for easier reference
    restart: always
    # No external port needed for n8n access
    # You can add a Traefik rule if you want external access to Stitcher

  # 3. MediaCMS Deployments (Adapted to use the same network)
  mediacms_db:
    image: postgres:17.2-alpine
    container_name: mediacms_db # Renamed to avoid conflicts
    volumes:
      # Ensure you create a 'postgres_data' directory at the root of your compose project
      - ./postgres_data:/var/lib/postgresql/data/ 
    restart: always
    environment:
      POSTGRES_USER: mediacms
      POSTGRES_PASSWORD: mediacms # CHANGE THIS!
      POSTGRES_DB: mediacms
      TZ: ${GENERIC_TIMEZONE} # Use the existing variable
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  mediacms_redis:
    image: "redis:alpine"
    container_name: mediacms_redis # Renamed to avoid conflicts
    restart: always
    healthcheck:
      test: ["CMD", "redis-cli","ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  mediacms_migrations:
    image: mediacms/mediacms:latest
    container_name: mediacms_migrations
    # Assuming you want to map a local directory for config/data
    # If this is not needed, remove this volume to use the image's default structure
    # - ./:/home/mediacms.io/mediacms/ 
    environment:
      ENABLE_UWSGI: 'no'
      ENABLE_NGINX: 'no'
      ENABLE_CELERY_SHORT: 'no'
      ENABLE_CELERY_LONG: 'no'
      ENABLE_CELERY_BEAT: 'no'
      ADMIN_USER: 'admin'
      ADMIN_EMAIL: 'admin@localhost'
      ADMIN_PASSWORD: '123' # CHANGE THIS!
    command: "./deploy/docker/prestart.sh"
    restart: on-failure
    depends_on:
      mediacms_redis:
        condition: service_healthy
      mediacms_db:
        condition: service_healthy

  mediacms_web:
    image: mediacms/mediacms:latest
    container_name: mediacms_web
    deploy:
      replicas: 1
    # Remove external port mapping '8080:80' and use Traefik instead
    # The internal port 80 is still used by the container
    # volumes:
    #   - ./:/home/mediacms.io/mediacms/
    environment:
      ENABLE_CELERY_BEAT: 'no'
      ENABLE_CELERY_SHORT: 'no'
      ENABLE_CELERY_LONG: 'no'
      ENABLE_MIGRATIONS: 'no'
    depends_on:
      - mediacms_migrations
    labels:
      # MediaCMS Traefik Labels (Assuming MediaCMS is accessed via a different subdomain)
      - traefik.enable=true
      - traefik.http.routers.mediacms.rule=Host(`media.${DOMAIN_NAME}`)
      - traefik.http.routers.mediacms.tls=true
      - traefik.http.routers.mediacms.entrypoints=web,websecure
      - traefik.http.routers.mediacms.tls.certresolver=mytlschallenge
      - traefik.http.middlewares.mediacms.headers.SSLRedirect=true
      - traefik.http.middlewares.mediacms.headers.STSSeconds=315360000
      - traefik.http.middlewares.mediacms.headers.browserXSSFilter=true
      - traefik.http.middlewares.mediacms.headers.contentTypeNosniff=true
      - traefik.http.middlewares.mediacms.headers.forceSTSHeader=true
      - traefik.http.middlewares.mediacms.headers.SSLHost=${DOMAIN_NAME}
      - traefik.http.middlewares.mediacms.headers.STSIncludeSubdomains=true
      - traefik.http.middlewares.mediacms.headers.STSPreload=true
      - traefik.http.routers.mediacms.middlewares=mediacms@docker

  mediacms_celery_beat:
    image: mediacms/mediacms:latest
    container_name: mediacms_celery_beat
    # volumes:
    #   - ./:/home/mediacms.io/mediacms/
    environment:
      ENABLE_UWSGI: 'no'
      ENABLE_NGINX: 'no'
      ENABLE_CELERY_SHORT: 'no'
      ENABLE_CELERY_LONG: 'no'
      ENABLE_MIGRATIONS: 'no'
    depends_on:
      - mediacms_redis

  mediacms_celery_worker:
    image: mediacms/mediacms:latest
    container_name: mediacms_celery_worker
    deploy:
      replicas: 1
    # volumes:
    #   - ./:/home/mediacms.io/mediacms/
    environment:
      ENABLE_UWSGI: 'no'
      ENABLE_NGINX: 'no'
      ENABLE_CELERY_BEAT: 'no'
      ENABLE_MIGRATIONS: 'no'
    depends_on:
      - mediacms_migrations

  ### END NEW SERVICES ###

volumes:
  n8n_data:
  traefik_data:
  # New volume for MediaCMS persistence
  postgres_data: