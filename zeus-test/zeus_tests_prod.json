{
  "name": "zeus_tests",
  "nodes": [
    {
      "parameters": {
        "operation": "runCustomScript",
        "scriptCode": "\n/**\n * n8n Puppeteer → Run Custom Script (revisado)\n * - Login + upload\n * - Auto‑scroll (contêiner OU janela)\n * - Corrida: sucesso (selector) VS erro (selector) VS texto \"Você acabou de economizar\"\n * - Diagnóstico: screenshot e último bodyText quando der timeout\n */\n\nconst INITIAL_URL = 'https://zeus.tjpa.jus.br/';\n\nconst LOGIN_BUTTON_SELECTOR = '[data-testid=\"stBaseButton-secondary\"]';\n//const SCROLL_CONTAINER_SELECTOR = '#root > div:nth-child(1) > div.withScreencast > div > div > section.stMain.st-emotion-cache-bm2z3a.eht7o1d1';\nconst SCROLL_CONTAINER_SELECTOR = '[data-testid=\"stMain\"]'\n\n//const VLL_ERROR_SELECTOR = '#tabs-bui2-tabpanel-0 > div > div > div > div:nth-child(6) > div > div > div > div';\n//const VLL_ERROR_SELECTOR = '[data-testid=\"stMain\"]'\n\nconst PROCESSING_TIMEOUT_MS = 600000; // 10 minutes (adjust as needed)\nconst USERNAME = 'danilo.nicioka';\nconst PASSWORD = 'Ad@maz080212'; // <-- use n8n credentials instead of hardcoding\nconst USERNAME_SELECTOR = '#username';\nconst PASSWORD_SELECTOR = '#password';\nconst CONFIRM_LOGIN_BUTTON_SELECTOR = '#kc-login';\n\nconst VIDEO_PATH = '/tmp/zeus/videos/zeusteste.mp4';\nconst FILE_UPLOAD_SELECTOR = '[data-testid=\"stFileUploaderDropzoneInput\"]';\n\n// ===================== CONFIGURÁVEIS =====================\n\n// Sucesso por seletor (adicione mais se souber os data-testid/classes)\nconst SUCCESS_SELECTORS = [\n  '[data-testid=\"stAlertContentSuccess\"]',\n  // '[role=\"alert\"].success', // exemplo — remova se não existir\n];\n\n// Falha por seletor (adicione seus casos)\n//const ERROR_SELECTORS = [\n  //'[data-testid=\"stAlertContentError\"]',\n  // '[role=\"alert\"].error',\n  // '[data-testid=\"stToast\"].error'\n//];\n\n// Sucesso por texto (case- & accent-insensitive)\nconst SUCCESS_TEXT_PATTERNS = [\n  'Você acabou de economizar',\n  //'Processamento concluído',\n];\n\n// Falha por texto (coloque aqui todas as mensagens que quer pegar)\nconst ERROR_TEXT_PATTERNS = [\n  'ConnectionError',\n  'Houve um problema ao processar sua requisição',\n  'Bad Gateway',\n  //'upload falhou',\n  //'vídeo inválido',\n  //'não suportado',\n  //'limite excedido',\n];\n\nconst SCROLL_STEP = 1200;\nconst SETTLE_DELAY = 100;\nconst MAX_IDLE_ROUNDS = 8;\n\n// ===================== UTILS =====================\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\n\nfunction getContext() {\n  // Se precisar de iframe, adapte aqui com FRAME_URL_CONTAINS\n  return { ctx: $page, inFrame: false };\n}\n\n// Rola o contêiner (se scrollável) ou a janela\nasync function stepScroll(ctx, stepPx, containerSel) {\n  return ctx.evaluate((step, cSel) => {\n    const container = cSel ? document.querySelector(cSel) : null;\n    const scrollable = (container && container.scrollHeight > container.clientHeight) ? container : null;\n    const scroller = scrollable || document.scrollingElement || document.body;\n\n    scroller.scrollTop += step;\n\n    return {\n      afterHeight: scroller.scrollHeight,\n      used: scrollable ? 'container' : 'document',\n    };\n  }, stepPx, containerSel);\n}\n\n// Converte lista de strings em função de teste accent-insensitive\nfunction normalize(s) {\n  return (s || '').normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n}\n\nfunction toTester(patterns) {\n  const needles = patterns.map((p) => normalize(p)).filter(Boolean);\n  return (hay) => {\n    const h = normalize(hay);\n    return needles.some((n) => h.includes(n));\n  };\n}\n\nconst testSuccessText = toTester(SUCCESS_TEXT_PATTERNS);\nconst testErrorText   = toTester(ERROR_TEXT_PATTERNS);\n\n// Tenta achar por **qualquer seletor**; retorna handle e o seletor que bateu\nasync function matchAnySelector(ctx, selectors) {\n  for (const sel of selectors) {\n    const h = await ctx.$(sel);\n    if (h) return { handle: h, selector: sel };\n  }\n  return null;\n}\n\n// Marca o **primeiro elemento** cujo innerText bate com qualquer padrão e devolve o handle\nasync function markElementByText(ctx, patterns, attrName) {\n  const id = `${attrName}-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  const marked = await ctx.evaluate((pats, attr, containerSel) => {\n    function normalize(s) {\n      return (s || '').normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n    }\n    const needles = pats.map((p) => normalize(p));\n    const container = containerSel ? document.querySelector(containerSel) : document.body;\n    const all = Array.from(container.querySelectorAll('*'));\n    for (const el of all) {\n      const t = el.innerText || el.textContent || '';\n      const h = normalize(t);\n      if (needles.some((n) => h.includes(n))) {\n        el.setAttribute(attr, id);\n        return id;\n      }\n    }\n    return null;\n  }, patterns, 'data-pptr-hit', SCROLL_CONTAINER_SELECTOR);\n\n  if (!marked) return null;\n  const handle = await ctx.$(`[data-pptr-hit=\"${id}\"]`);\n  return handle ? { handle, selector: `[data-pptr-hit=\"${id}\"]` } : null;\n}\n\n// Aguarda que o elemento tenha texto não vazio (se for alerta com <p>)\n\nasync function waitForNonEmptyText(ctx, handle, maxWaitMs) {\n  const attr = await handle.evaluate((el) => el.getAttribute('data-pptr-hit'));\n  if (attr) {\n    await ctx.waitForFunction(\n      (a) => {\n        const el = document.querySelector(`[data-pptr-hit=\"${a}\"]`);\n        if (!el) return false;\n        const t = el.innerText || el.textContent || '';\n        return !!t.trim();\n      },\n      { timeout: maxWaitMs },\n      attr\n    ).catch(() => {});\n    return;\n  }\n\n  const deadline = Date.now() + maxWaitMs;\n  while (Date.now() < deadline) {\n    const ok = await handle.evaluate((el) => {\n      const t = el.innerText || el.textContent || '';\n      return !!t.trim();\n    }).catch(() => true);\n    if (ok) break;\n    await delay(250);\n  }\n}\n\n// Screenshot de um handle\nasync function screenshotHandle(el) {\n  // Centraliza na viewport\n  try {\n    await el.evaluate((node) => node.scrollIntoView({ block: 'center', inline: 'center' }));\n  } catch {}\n  await delay(200);\n  const base64 = await el.screenshot({ type: 'png', encoding: 'base64' });\n  const box = await el.boundingBox();\n  return { data: base64, mimeType: 'image/png', fileName: `alert-${Date.now()}.png`, box };\n}\n\n/** Diagnóstico em caso de timeout */\nasync function captureDiagnostics() {\n  const buf = await $page.screenshot({ fullPage: true }).catch(() => null);\n  const bodyText = await $page.evaluate(() => document.body.innerText.slice(-5000)).catch(() => '');\n  return { screenshotBase64: buf ? buf.toString('base64') : null, bodyTailText: bodyText };\n}\n\n// ===================== CORRIDA DE CONDIÇÕES =====================\n// Retorna {status: 'success'|'error'|'timeout', matchType: 'selector'|'text', selector?, textPattern?, handle?}\nasync function waitForOutcomeMulti(ctx) {\n  const start = Date.now();\n  let lastHeight = -1;\n  let idleRounds = 0;\n\n  while ((Date.now() - start) < PROCESSING_TIMEOUT_MS) {\n    // 1) tenta sucesso/falha por SELETOR\n    const okSel  = await matchAnySelector(ctx, SUCCESS_SELECTORS);\n    if (okSel) return { status: 'success', matchType: 'selector', selector: okSel.selector, handle: okSel.handle };\n\n    //const errSel = await matchAnySelector(ctx, ERROR_SELECTORS);\n    //if (errSel) return { status: 'error', matchType: 'selector', selector: errSel.selector, handle: errSel.handle };\n\n    // 2) leitura rápida do bodyText + testers\n    const bodyText = await ctx.evaluate(() => document.body.innerText || '');\n\n    if (testSuccessText(bodyText)) {\n      // marca e resolve o elemento para screenshot\n      const okText = await markElementByText(ctx, SUCCESS_TEXT_PATTERNS, 'pptr-success');\n      if (okText) return { status: 'success', matchType: 'text', textPattern: 'SUCCESS_TEXT_PATTERNS', selector: okText.selector, handle: okText.handle };\n    }\n\n    if (testErrorText(bodyText)) {\n      const errText = await markElementByText(ctx, ERROR_TEXT_PATTERNS, 'pptr-error');\n      if (errText) return { status: 'error', matchType: 'text', textPattern: 'ERROR_TEXT_PATTERNS', selector: errText.selector, handle: errText.handle };\n    }\n\n    // 3) passo de scroll\n    const stats = await stepScroll(ctx, SCROLL_STEP, SCROLL_CONTAINER_SELECTOR);\n    if (stats.afterHeight === lastHeight) idleRounds += 1;\n    else { idleRounds = 0; lastHeight = stats.afterHeight; }\n    await delay(SETTLE_DELAY);\n\n    // 4) fundo absoluto se estagnar\n    if (idleRounds >= MAX_IDLE_ROUNDS) {\n      await ctx.evaluate((cSel) => {\n        const container = cSel ? document.querySelector(cSel) : null;\n        const scroller = (container && container.scrollHeight > container.clientHeight)\n          ? container : (document.scrollingElement || document.body);\n        scroller.scrollTop = scroller.scrollHeight;\n      }, SCROLL_CONTAINER_SELECTOR);\n      await delay(Math.max(SETTLE_DELAY, 250));\n      idleRounds = 0;\n    }\n  }\n\n  return { status: 'timeout' };\n}\n\n// ===================== USO NO SEU FLUXO =====================\nasync function findAlertAndScreenshot() {\n  const { ctx, inFrame } = getContext();\n\n  // Corrida por sucesso/falha (seletor + texto)\n  const outcome = await waitForOutcomeMulti(ctx);\n\n  if (outcome.status === 'timeout') {\n    const diag = await captureDiagnostics();\n    throw new Error(`Timeout (${PROCESSING_TIMEOUT_MS}ms): nenhum alerta encontrado. Último trecho de bodyText:\\n${diag.bodyTailText || '(vazio)'}\\n`);\n  }\n\n  // Garantir que o elemento tenha conteúdo (não estritamente necessário aqui)\n  try { await waitForNonEmptyText(ctx, outcome.handle, Math.min(20000, PROCESSING_TIMEOUT_MS)); } catch {}\n\n  // Hi-DPI opcional para nitidez\n  const originalViewport = $page.viewport();\n  await $page.setViewport({ ...(originalViewport || { width: 1280, height: 800 }), deviceScaleFactor: 2 });\n\n  // Screenshot do elemento encontrado (seletor ou texto)\n  const shot = await screenshotHandle(outcome.handle);\n\n  // Texto capturado do próprio elemento (se quiser registrar)\n  const elementText = await outcome.handle.evaluate((el) => el.innerText || el.textContent || '');\n\n  return [{\n    json: {\n      status: outcome.status,                // 'success' ou 'error'\n      matchType: outcome.matchType,          // 'selector' ou 'text'\n      matchSelector: outcome.selector || null,\n      matchTextPattern: outcome.textPattern || null,\n      elementText,\n      inFrame,\n      url: $page.url(),\n      capturedAt: new Date().toISOString(),\n    },\n    binary: { elementScreenshot: shot }\n  }];\n}\n\nasync function main() {\n  // 1) abre a página\n  await $page.goto(INITIAL_URL, { waitUntil: 'domcontentloaded' });\n\n  // 2) botão de login (evite nth-child em produção; aqui mantido)\n  await $page.waitForSelector(LOGIN_BUTTON_SELECTOR, { visible: true, timeout: 30000 });\n  await Promise.all([\n    $page.waitForNavigation({ waitUntil: 'load', timeout: 60000 }),\n    $page.click(LOGIN_BUTTON_SELECTOR),\n  ]);\n\n  // 3) form de login\n  await $page.waitForSelector(USERNAME_SELECTOR, { visible: true, timeout: 60000 });\n  await $page.waitForSelector(PASSWORD_SELECTOR, { visible: true, timeout: 60000 });\n  await $page.waitForSelector(CONFIRM_LOGIN_BUTTON_SELECTOR, { visible: true, timeout: 60000 });\n\n  await $page.type(USERNAME_SELECTOR, USERNAME, { delay: 40 });\n  await $page.type(PASSWORD_SELECTOR, PASSWORD, { delay: 40 });\n\n  await Promise.all([\n    $page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 60000 }),\n    $page.click(CONFIRM_LOGIN_BUTTON_SELECTOR),\n  ]);\n\n  // 4) upload\n  const fileInput = await $page.waitForSelector(FILE_UPLOAD_SELECTOR, { visible: true, timeout: 60000 });\n  await fileInput.uploadFile(VIDEO_PATH);\n\n  // 5) aguarda resultado\n  return await findAlertAndScreenshot();\n}\n\nreturn await main();\n",
        "options": {
          "browserWSEndpoint": "http://172.17.0.136:4000?token=6R0W53R135510"
        }
      },
      "type": "n8n-nodes-puppeteer.puppeteer",
      "typeVersion": 1,
      "position": [
        416,
        -256
      ],
      "id": "66912972-553d-4edd-9ae9-0aad401f6c9f",
      "name": "zeus"
    },
    {
      "parameters": {
        "chatId": "860982084",
        "text": "={{ $json.elementText }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        640,
        -352
      ],
      "id": "8e30676f-12c7-40e3-9084-1ab4580e2330",
      "name": "Send a text message",
      "webhookId": "e4be8b4c-4d20-4f82-8785-7f04451cbd1a",
      "credentials": {
        "telegramApi": {
          "id": "Sdp8qFRZxWRwbxIE",
          "name": "Telegram account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "860982084",
        "binaryData": true,
        "binaryPropertyName": "elementScreenshot",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        640,
        -160
      ],
      "id": "6d24471d-287c-4cbb-b190-e2f187da96d7",
      "name": "Send a photo message",
      "webhookId": "e1b8046d-df78-4fb4-a599-87eca8d52116",
      "credentials": {
        "telegramApi": {
          "id": "Sdp8qFRZxWRwbxIE",
          "name": "Telegram account 2"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 8
            },
            {
              "triggerAtHour": 14
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        192,
        -256
      ],
      "id": "ef7f4605-7183-4b66-9698-4f661019e16e",
      "name": "Schedule Trigger"
    }
  ],
  "pinData": {},
  "connections": {
    "zeus": {
      "main": [
        [
          {
            "node": "Send a photo message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "zeus",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "388dd4f3-7df8-472d-8d70-783c4f9a4e55",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "4f83938c604fd61ef30b704f19803da6d669ad618b6dcce28b5567b3a82953c1"
  },
  "id": "6KsD7KiFdLkoamba",
  "tags": [
    {
      "updatedAt": "2025-12-24T19:48:32.141Z",
      "createdAt": "2025-12-24T19:48:32.141Z",
      "id": "qhEErSt43Ib8lZIX",
      "name": "zeus"
    }
  ]
}