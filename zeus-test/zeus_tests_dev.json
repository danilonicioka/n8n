{
  "name": "zeus_tests_dev",
  "nodes": [
    {
      "parameters": {
        "operation": "runCustomScript",
        "scriptCode": "\n/**\n * n8n Puppeteer → Run Custom Script (revisado)\n * - Login + upload\n * - Auto‑scroll (contêiner OU janela)\n * - Corrida: sucesso (selector) VS erro (selector) VS texto \"Você acabou de economizar\"\n * - Diagnóstico: screenshot e último bodyText quando der timeout\n */\n\n// ===================== CONFIGURÁVEIS =====================\n\nconst INITIAL_URL = 'https://zeus.tjpa.jus.br/';\nconst SCROLL_CONTAINER_SELECTOR = '[data-testid=\"stMain\"]'\n\nconst LOGIN_BUTTON_SELECTOR = '[data-testid=\"stBaseButton-secondary\"]';\n\nconst USERNAME_SELECTOR = '#username';\nconst PASSWORD_SELECTOR = '#password';\nconst USERNAME = 'danilo.nicioka';\nconst PASSWORD = 'Ad@maz080212';\nconst CONFIRM_LOGIN_BUTTON_SELECTOR = '#kc-login';\n\nconst FILE_UPLOAD_SELECTOR = '[data-testid=\"stFileUploaderDropzoneInput\"]';\nconst VIDEO_PATH = '/tmp/zeus/videos/zeusteste.mp4';\nconst PROCESSING_TIMEOUT_MS = 300000; // 5 minutes\n\nconst SCROLL_STEP = 1200;\nconst SETTLE_DELAY = 100;\nconst MAX_IDLE_ROUNDS = 8;\n\n// Sucesso por seletor (adicione mais se souber os data-testid/classes)\nconst SUCCESS_SELECTORS = [\n  '[data-testid=\"stAlertContentSuccess\"]',\n];\n\n// Falha por seletor\nconst ERROR_SELECTORS = [\n  '[data-testid=\"stAlertContentError\"]',\n];\n\n// Sucesso por texto (case- & accent-insensitive)\nconst SUCCESS_TEXT_PATTERNS = [\n  'Você acabou de economizar',\n];\n\n// Falha por texto (coloque aqui todas as mensagens que quer pegar)\nconst ERROR_TEXT_PATTERNS = [\n  'ConnectionError',\n  'Houve um problema ao processar sua requisição',\n  'Bad Gateway',\n];\n\n// ===================== UTILS =====================\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\n\nfunction getContext() {\n  // Se precisar de iframe, adapte aqui com FRAME_URL_CONTAINS\n  return { ctx: $page, inFrame: false };\n}\n\n// Rola o contêiner (se scrollável) ou a janela\nasync function stepScroll(ctx, stepPx, containerSel) {\n  return ctx.evaluate((step, cSel) => {\n    const container = cSel ? document.querySelector(cSel) : null;\n    const scrollable = (container && container.scrollHeight > container.clientHeight) ? container : null;\n    const scroller = scrollable || document.scrollingElement || document.body;\n\n    scroller.scrollTop += step;\n\n    return {\n      afterHeight: scroller.scrollHeight,\n      used: scrollable ? 'container' : 'document',\n    };\n  }, stepPx, containerSel);\n}\n\n// Converte lista de strings em função de teste accent-insensitive\nfunction normalize(s) {\n  return (s || '').normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n}\n\nfunction toTester(patterns) {\n  const needles = patterns.map((p) => normalize(p)).filter(Boolean);\n  return (hay) => {\n    const h = normalize(hay);\n    return needles.some((n) => h.includes(n));\n  };\n}\n\nconst testSuccessText = toTester(SUCCESS_TEXT_PATTERNS);\nconst testErrorText   = toTester(ERROR_TEXT_PATTERNS);\n\n// Tenta achar por **qualquer seletor**; retorna handle e o seletor que bateu\nasync function matchAnySelector(ctx, selectors) {\n  for (const sel of selectors) {\n    const h = await ctx.$(sel);\n    if (h) return { handle: h, selector: sel };\n  }\n  return null;\n}\n\n// Marca o **primeiro elemento** cujo innerText bate com qualquer padrão e devolve o handle\nasync function markElementByText(ctx, patterns, attrName) {\n  const id = `${attrName}-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  const marked = await ctx.evaluate((pats, attr, containerSel) => {\n    function normalize(s) {\n      return (s || '').normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n    }\n    const needles = pats.map((p) => normalize(p));\n    const container = containerSel ? document.querySelector(containerSel) : document.body;\n    const all = Array.from(container.querySelectorAll('*'));\n    for (const el of all) {\n      const t = el.innerText || el.textContent || '';\n      const h = normalize(t);\n      if (needles.some((n) => h.includes(n))) {\n        el.setAttribute(attr, id);\n        return id;\n      }\n    }\n    return null;\n  }, patterns, 'data-pptr-hit', SCROLL_CONTAINER_SELECTOR);\n\n  if (!marked) return null;\n  const handle = await ctx.$(`[data-pptr-hit=\"${id}\"]`);\n  return handle ? { handle, selector: `[data-pptr-hit=\"${id}\"]` } : null;\n}\n\n// Aguarda que o elemento tenha texto não vazio (se for alerta com <p>)\n\nasync function waitForNonEmptyText(ctx, handle, maxWaitMs) {\n  const attr = await handle.evaluate((el) => el.getAttribute('data-pptr-hit'));\n  if (attr) {\n    await ctx.waitForFunction(\n      (a) => {\n        const el = document.querySelector(`[data-pptr-hit=\"${a}\"]`);\n        if (!el) return false;\n        const t = el.innerText || el.textContent || '';\n        return !!t.trim();\n      },\n      { timeout: maxWaitMs },\n      attr\n    ).catch(() => {});\n    return;\n  }\n\n  const deadline = Date.now() + maxWaitMs;\n  while (Date.now() < deadline) {\n    const ok = await handle.evaluate((el) => {\n      const t = el.innerText || el.textContent || '';\n      return !!t.trim();\n    }).catch(() => true);\n    if (ok) break;\n    await delay(250);\n  }\n}\n\n// Screenshot de um handle\nasync function screenshotHandle(el) {\n  // Centraliza na viewport\n  try {\n    await el.evaluate((node) => node.scrollIntoView({ block: 'center', inline: 'center' }));\n  } catch {}\n  await delay(200);\n  const base64 = await el.screenshot({ type: 'png', encoding: 'base64' });\n  const box = await el.boundingBox();\n  return { data: base64, mimeType: 'image/png', fileName: `alert-${Date.now()}.png`, box };\n}\n\n// Varre todos os elementos de cada seletor e valida o texto com um \"tester\" (ex.: testErrorText)\nasync function matchSelectorWithTextTester(ctx, selectors, textTester, nonEmptyWaitMs = 5000) {\n  for (const sel of selectors) {\n    const handles = await ctx.$$(sel);\n    for (const h of handles) {\n      // evita hidratação incompleta\n      try { await waitForNonEmptyText(ctx, h, nonEmptyWaitMs); } catch {}\n\n      const t = await h.evaluate(el => el.innerText || el.textContent || '');\n      if (textTester(t)) {\n        return { handle: h, selector: sel, text: t };\n      } else {\n        // não é o erro que queremos; libera o handle\n        try { await h.dispose?.(); } catch {}\n      }\n    }\n  }\n  return null;\n}\n\n\n// ===================== CORRIDA DE CONDIÇÕES =====================\n// Retorna {status: 'success'|'error'|'timeout', matchType: 'selector'|'text', selector?, textPattern?, handle?}\nasync function waitForOutcomeMulti(ctx) {\n  const start = Date.now();\n  let lastHeight = -1;\n  let idleRounds = 0;\n\n  while ((Date.now() - start) < PROCESSING_TIMEOUT_MS) {\n    // 1) tenta sucesso/falha por SELETOR\n    \n    const okSelValidated = await matchSelectorWithTextTester(ctx, SUCCESS_SELECTORS, testSuccessText, 5000);\n    if (okSelValidated) {\n      return {\n        status: 'success',\n        matchType: 'selector',\n        selector: okSelValidated.selector,\n        handle: okSelValidated.handle,\n        textPattern: 'SUCCESS_TEXT_PATTERNS'\n      };\n    }\n    \n    const errSelValidated = await matchSelectorWithTextTester(ctx, ERROR_SELECTORS, testErrorText, 5000);\n    if (errSelValidated) {\n      return {\n        status: 'error',\n        matchType: 'selector',\n        selector: errSelValidated.selector,\n        handle: errSelValidated.handle,\n        textPattern: 'ERROR_TEXT_PATTERNS', // opcional: você pode guardar errSelValidated.text se quiser -> errSelValidated.text.slice(0, 500)\n      };\n    }\n\n    /**\n    // 2) leitura rápida do bodyText + testers\n    const bodyText = await ctx.evaluate(() => document.body.innerText || '');\n\n    if (testSuccessText(bodyText)) {\n      // marca e resolve o elemento para screenshot\n      const okText = await markElementByText(ctx, SUCCESS_TEXT_PATTERNS, 'pptr-success');\n      if (okText) return { status: 'success', matchType: 'text', textPattern: 'SUCCESS_TEXT_PATTERNS', selector: okText.selector, handle: okText.handle };\n    }\n\n    if (testErrorText(bodyText)) {\n      const errText = await markElementByText(ctx, ERROR_TEXT_PATTERNS, 'pptr-error');\n      if (errText) return { status: 'error', matchType: 'text', textPattern: 'ERROR_TEXT_PATTERNS', selector: errText.selector, handle: errText.handle };\n    }\n    */\n\n    // 3) passo de scroll\n    const stats = await stepScroll(ctx, SCROLL_STEP, SCROLL_CONTAINER_SELECTOR);\n    if (stats.afterHeight === lastHeight) idleRounds += 1;\n    else { idleRounds = 0; lastHeight = stats.afterHeight; }\n    await delay(SETTLE_DELAY);\n\n    // 4) fundo absoluto se estagnar\n    if (idleRounds >= MAX_IDLE_ROUNDS) {\n      await ctx.evaluate((cSel) => {\n        const container = cSel ? document.querySelector(cSel) : null;\n        const scroller = (container && container.scrollHeight > container.clientHeight)\n          ? container : (document.scrollingElement || document.body);\n        scroller.scrollTop = scroller.scrollHeight;\n      }, SCROLL_CONTAINER_SELECTOR);\n      await delay(Math.max(SETTLE_DELAY, 250));\n      idleRounds = 0;\n    }\n  }\n\n  return { status: 'timeout' };\n}\n\n// ===================== USO NO SEU FLUXO =====================\nasync function findAlertAndScreenshot() {\n  const { ctx, inFrame } = getContext();\n\n  // Corrida por sucesso/falha (seletor + texto)\n  const outcome = await waitForOutcomeMulti(ctx);\n\n  if (outcome.status === 'timeout') {\n    const diag = await captureDiagnostics();\n    throw new Error(`Timeout (${PROCESSING_TIMEOUT_MS}ms): nenhum alerta encontrado. Último trecho de bodyText:\\n${diag.bodyTailText || '(vazio)'}\\n`);\n  }\n\n  // Garantir que o elemento tenha conteúdo (não estritamente necessário aqui)\n  try { await waitForNonEmptyText(ctx, outcome.handle, Math.min(20000, PROCESSING_TIMEOUT_MS)); } catch {}\n\n  // Hi-DPI opcional para nitidez\n  const originalViewport = $page.viewport();\n  await $page.setViewport({ ...(originalViewport || { width: 1280, height: 800 }), deviceScaleFactor: 2 });\n\n  // Screenshot do elemento encontrado (seletor ou texto)\n  const shot = await screenshotHandle(outcome.handle);\n\n  // Texto capturado do próprio elemento (se quiser registrar)\n  const elementText = await outcome.handle.evaluate((el) => el.innerText || el.textContent || '');\n\n  return [{\n    json: {\n      status: outcome.status,                // 'success' ou 'error'\n      matchType: outcome.matchType,          // 'selector' ou 'text'\n      matchSelector: outcome.selector || null,\n      matchTextPattern: outcome.textPattern || null,\n      elementText,\n      inFrame,\n      url: $page.url(),\n      capturedAt: new Date().toISOString(),\n    },\n    binary: { elementScreenshot: shot }\n  }];\n}\n\nasync function main() {\n  // 1) abre a página\n  await $page.goto(INITIAL_URL, { waitUntil: 'domcontentloaded' });\n\n  // 2) botão de login (evite nth-child em produção; aqui mantido)\n  await $page.waitForSelector(LOGIN_BUTTON_SELECTOR, { visible: true, timeout: 30000 });\n  await Promise.all([\n    $page.waitForNavigation({ waitUntil: 'load', timeout: 60000 }),\n    $page.click(LOGIN_BUTTON_SELECTOR),\n  ]);\n\n  // 3) form de login\n  await $page.waitForSelector(USERNAME_SELECTOR, { visible: true, timeout: 60000 });\n  await $page.waitForSelector(PASSWORD_SELECTOR, { visible: true, timeout: 60000 });\n  await $page.waitForSelector(CONFIRM_LOGIN_BUTTON_SELECTOR, { visible: true, timeout: 60000 });\n\n  await $page.type(USERNAME_SELECTOR, USERNAME, { delay: 40 });\n  await $page.type(PASSWORD_SELECTOR, PASSWORD, { delay: 40 });\n\n  await Promise.all([\n    $page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 60000 }),\n    $page.click(CONFIRM_LOGIN_BUTTON_SELECTOR),\n  ]);\n\n  // 4) upload\n  const fileInput = await $page.waitForSelector(FILE_UPLOAD_SELECTOR, { visible: true, timeout: 60000 });\n  await fileInput.uploadFile(VIDEO_PATH);\n\n  // 5) aguarda resultado\n  return await findAlertAndScreenshot();\n}\n\nreturn await main();",
        "options": {
          "browserWSEndpoint": "http://browserless:3000?token=6R0W53R135510"
        }
      },
      "type": "n8n-nodes-puppeteer.puppeteer",
      "typeVersion": 1,
      "position": [
        832,
        128
      ],
      "id": "79a0f9c1-1837-436e-a331-74198d7a46ef",
      "name": "zeus"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 8
            },
            {
              "triggerAtHour": 14
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        384,
        128
      ],
      "id": "f2025ca8-3e3c-46b5-9e20-fa8a8fbbf666",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "method": "HEAD",
        "url": "http://browserless:8080/videos/zeusteste.mp4",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        608,
        128
      ],
      "id": "9336ba6e-9504-44a0-985d-b060b700b093",
      "name": "HTTP Request",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "25c954bb-12d8-4b98-986b-d533be77a850",
              "leftValue": "={{ $json.status }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1056,
        320
      ],
      "id": "7ec602a1-9144-4166-a3ea-67f23510e367",
      "name": "result"
    },
    {
      "parameters": {
        "chatId": "832907774",
        "text": "={{ $json.elementText }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1056,
        -64
      ],
      "id": "1f46c553-9eba-44be-b4e7-3b7cdbf12562",
      "name": "Send a text message",
      "webhookId": "e4be8b4c-4d20-4f82-8785-7f04451cbd1a",
      "credentials": {
        "telegramApi": {
          "id": "iXRoYA9RyskBHofp",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "operation": "sendPhoto",
        "chatId": "832907774",
        "binaryData": true,
        "binaryPropertyName": "elementScreenshot",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1056,
        128
      ],
      "id": "ccdb996f-3cc4-4a80-9b0d-8eaad5ce84db",
      "name": "Send a photo message",
      "webhookId": "e1b8046d-df78-4fb4-a599-87eca8d52116",
      "credentials": {
        "telegramApi": {
          "id": "iXRoYA9RyskBHofp",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "docker compose down",
        "cwd": "/root/ollama"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1280,
        320
      ],
      "id": "9791a47f-238b-4bf4-98be-5b2cf7658722",
      "name": "down"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "docker compose up -d",
        "cwd": "/root/ollama"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1504,
        320
      ],
      "id": "26211000-9f41-4ac4-9012-0636d718300c",
      "name": "up"
    },
    {
      "parameters": {
        "authentication": "privateKey",
        "command": "docker compose logs -n 5 vllm-qwen3-14B | grep 'Application startup'",
        "cwd": "/root/ollama"
      },
      "type": "n8n-nodes-base.ssh",
      "typeVersion": 1,
      "position": [
        1952,
        320
      ],
      "id": "1fa7edd9-10c3-4b0f-8ab1-e7a25b457cff",
      "name": "logs"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "22f2ff9d-a3e2-492d-b9e4-dbb6fcf3df27",
              "leftValue": "={{ $json.code }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2176,
        320
      ],
      "id": "56b31343-2ba1-4813-a0d7-df55e593d8fb",
      "name": "check_start"
    },
    {
      "parameters": {
        "amount": 15,
        "unit": "minutes"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1728,
        320
      ],
      "id": "b24a0151-443a-4143-9e64-339892e667cf",
      "name": "Wait",
      "webhookId": "59aaea05-b5a1-4435-ac6f-9664720f304c"
    }
  ],
  "pinData": {},
  "connections": {
    "zeus": {
      "main": [
        [
          {
            "node": "result",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send a photo message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "zeus",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "result": {
      "main": [
        [],
        [
          {
            "node": "down",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "down": {
      "main": [
        [
          {
            "node": "up",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "up": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "logs": {
      "main": [
        [
          {
            "node": "check_start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_start": {
      "main": [
        [],
        [
          {
            "node": "logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1085a523-50af-4ce2-bb9d-ea887db1edde",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "4f83938c604fd61ef30b704f19803da6d669ad618b6dcce28b5567b3a82953c1"
  },
  "id": "7GlTCj5QbPeB36YM",
  "tags": [
    {
      "updatedAt": "2025-12-30T12:54:53.778Z",
      "createdAt": "2025-12-30T12:54:53.778Z",
      "id": "meUj7ytCkRKqHX6I",
      "name": "zeus"
    }
  ]
}